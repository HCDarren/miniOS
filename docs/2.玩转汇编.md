## 书籍推荐
《汇编语言》  
《x86汇编语言：从实模式到保护模式（第二版）》

## 汇编基本介绍
### 1、什么是汇编？我们对汇编的理解？

是一种低级编程语言，介于机器语言（二进制的0/1代码）和高级语言（如C/C++/Python）之间。它使用助记符​（如MOV、ADD）代替机器指令的原始二进制形式，使得程序员能够以更可读的方式编写直接控制硬件的代码。

### 2、x86汇编与arm汇编
- x86/x64：复杂指令集，广泛用于桌面/服务器（Intel/AMD CPU）。
- ​ARM：精简指令集，主导移动设备（手机、平板）和物联网。
- ​RISC-V：新兴的开源指令集，适用于嵌入式和服务器。
- ​不同架构的汇编语法差异较大​（如x86的复杂指令 vs. ARM的精简指令）。

### 3、AT&T 语法与 Intel 语法  
#### AT&T 语法​特点：
- 操作数顺序为源, 目标​（与Intel语法相反）。  
- 使用%前缀表示寄存器，$前缀表示立即数。    
```cpp
start:
  movl $4, %eax         ;sys_write
  movl $1, %ebx         ;stdout
  movl $message, %ecx   ;指向字符串
  movl $13, %edx        ;字符串长度
  int $0x80             ;Linux中断调用
message:
  "Hello World!\n"
```
#### Intel 语法特点  
- 操作数顺序为目标, 源​（与AT&T语法相反）。   
- 不需要 % 前缀表示寄存器，立即数可直接写数字。  
```cpp
start:
  mov eax, 4         ;sys_write
  mov ebx, 1         ;stdout
  mov ecx, message   ;指向字符串
  mov edx, 13        ;字符串长度
  int 0x80           ;Linux中断调用
message:
  "Hello World!\n"
```

## 寄存器、cpu 缓存、内存等如何理解？
寄存器（CPU内部） → CPU缓存（L1/L2/L3） → 内存（RAM/ROM）
- ​寄存器：是CPU的“工作台”，用于快速处理数据。
- ​CPU 缓存：临时就近的存放书籍区域。
- ​内存：类比于"仓库"。

## 常用寄存器

### 1、通用寄存器（General-Purpose Registers）​
| 寄存器 | 32位模式用途      |示例 |
|--------|----------------|------------------------|
|​EAX|通用累加器（算术运算、返回值）|add eax, ebx|
|​EBX|通用基址寄存器（数据存储）|mov ebx, [eax]|
|​ECX|计数器（循环控制）|loop print|
|​EDX|数据寄存器（I/O操作、乘除法辅助）|mov esi, [eax]|
|​ESI|源索引寄存器（字符串操作）|mov ebx, [eax]|
|​EDI|通用基址寄存器（数据存储）|mov ebx, [eax]|
|​ESP|通用基址寄存器（数据存储）|mov ebx, [eax]|
|​EBP|基址指针（函数参数/局部变量访问）|mov ebp, esp|

### 2、段寄存器（Segment Registers）​
|寄存器	|用途	|示例|
|--------|------|-----|
|​CS​	|代码段寄存器（指向程序代码的内存段）	|jmp cs:0x1000|
|​DS​	|数据段寄存器（指向全局数据的内存段）	|mov eax, [ds:0x1000]|
|​ES​	|附加段寄存器（字符串操作默认段）	|mov eax, [es:0x1000]|
|​FS​	|附加段寄存器（Windows API相关）	|mov eax, [fs:0x1000]
|​SS​	|栈寄存器 |mov ss, 0x00|

### ​3、状态寄存器（Status Register）​
|标志位	|含义	|设置条件|
|--------|------|-----|
|​CF​	|进位标志（Carry Flag）	|加法/减法产生进位或借位|
|​ZF​	|零标志（Zero Flag）|结果为零|
|SF​	|符号标志（Sign Flag）|结果为负数|
|OF​	|溢出标志（Overflow Flag）|有符号运算溢出|
|AF​	|辅助进位标志（Auxiliary Carry）|低四位运算产生的进位|
|PF​	|奇偶标志（Parity Flag）|结果二进制中1的个数为奇数|
|DF​	|方向标志（Direction Flag）|控制字符串操作方向（递增/递减）|

### 4、指令指针寄存器（Instruction Pointer）​
​EIP​（32位） / ​RIP​（64位）：存储下一条指令的地址。

### ​5、特殊用途寄存器
|寄存器|用途	|示例|
|--------|------|-----|
|cr0|​	启用/禁用保护模式、分页等|	mov cr0, 0x80000001|
|cr3|​	管理页表基址（分页机制）|	mov cr3, eax|
|cr4|​	控制高级功能（SMEP、PAE等）|	or cr4, 0x1000|
|lgdt| 全局描述符寄存器 | lgdt [gdt_ptr]|
|ldtr|​	局部描述符寄存器|	ldtr [ldtr_ptr]|

## al、ax、eax 与 rax
| 寄存器 | 位数  | 属于架构       | 包含关系               | 典型用途                          |
|--------|-------|----------------|------------------------|-----------------------------------|
| ​**al**​  | 8位   | x86/x64        | `rax` 的最低8位          | 字节级操作（ASCII字符、位掩码）      |
| ​**ax**​  | 16位  | x86/x64        | `rax` 的低16位          | 16位整数运算、指针（旧系统）        |
| ​**eax**| 32位  | x86/x64        | `rax` 的低32位          | 32位整数运算、系统调用参数（Linux） |
| ​**rax**| 64位  | x86/x64        | 独立64位寄存器           | 64位整数运算、通用寄存器            |

## 汇编常用指令

### 1、移动指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**mov**​  | 将数据从一个操作数复制到另一个	   | mov eax, 42        |

### 2、算术运算指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**add**​  | 加法 | add eax, ebx       |
| ​**sub**​  | 减法	   | sub ecx, edx        |
| ​**mul**​  | 乘法（结果存入 EDX:EAX）	   | mul ecx        |
| ​**div**​  | 整除（商存入 EAX，余数 EDX）	   | div ebx       |
| ​**inc**​  | 自增1   | inc eax       |
| ​**dec**​  | 自减1	   | dec eax        |

### 3、位操作指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**and**​  | 按位与 | and eax, 0xff       |
| ​**or**​  | 按位或	   | or ebx, 0x80        |
| ​**xor**​  | 按位异或	   | xor ecx, edx        |
| ​**not**​  | 按位取反	   | not eax       |
| ​**shl/sar**​  | 左移/算术右移	   | shl eax, 3      |
| ​**rol/ror**​  | 循环左移/右移	   | rol eax, 1        |

### 4、控制流指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**jmp**​  | 无条件跳转 | jmp label       |
| ​**je/jne**​  | 条件跳转（等于/不等于）	   | cmp eax, 5; je equal        |
| ​**jg/jl**​  | 大于/小于跳转	   | jg greater        |
| ​**call**​  | 调用子程序	   | call func       |
| ​**ret**​  | 返回主程序	   | ret      |
| ​**loop**​  | 基于 ECX 的循环	   | loop start        |

### 5、字符串操作指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**movsb**​  | 字节移动 | movsb esi, edi       |
| ​**cmpsb**​  | 字节比较	   | cmpsb esi, edi        |
| ​**rep**​  | 重复执行字符串指令   | rep movsb      |

### 6、系统调用与中断指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**syscall**​  | 触发系统调用（x86-64） | syscall      |
| ​**int**​  | 触发软中断（x86）	   | int 0x80        |
| ​**hlt**​  | 停止CPU执行   | hlt     |

### 7、堆栈操作指令
| 指令 | 作用  | 示例       |
|--------|-------|----------------|
| ​**push**​  | 压入数据到栈顶 | push eax      |
| ​**pop**​  | 弹出栈顶数据到寄存器	   | pop eax        |

## 汇编练习题
1、屏幕打印 "Hello World!"  
2、将任意数字输出到屏幕  
3、将两个立即数相加，结果存入寄存器 eax, 输出到屏幕   
4、比较两个数，如果 a > b 输出 "YES"，否则输出 "NO"  
5、for 循环计算 1 + 2 + ... + n，其中 n = 100，输出到屏幕"1+2+3+...+100 = 5050"  
6、找到数组 [3, 7, 2, 9, 1] 中的最大值，输出到屏幕  
7、将字符串 "Hello" 反转为 "olleH" ，输出到屏幕   
8、统计字符串 "Hello, World!" 的长度（不包括终止符 \0）。  
9、斐波那契数列（递归与非递归实现）​目标：计算第 n 项斐波那契数（例如 n=5 应输出 5）。  
10、实现任意排序算法

## 8086实模式与保护模式
### 实模式（Real Mode）​
- 8086/8088 处理器的运行模式，​16位架构。
- 寄存器是 16 位的，但是支持 20 位物理内存寻址（最大 1MB）。
- 数据地址​ = ds << 4 + 偏移量。
- 程序原则上可以访问任何数据内存也可以执行任意内存代码

### 保护模式（Protected Mode）​
- 80286 及后续处理器引入，支持 ​32位寻址​和​内存保护。  
- ​内存寻址​线性地址​ = 段基址 + 偏移量  
- 支持​分段+分页，最大 4GB（32位）或更大（64位）。  
- 段寄存器（CS、DS、ES、SS）存储​段描述符索引​（指向 GDT 中的段描述符）。  
- 支持​内存保护，每个段有​访问权限​（如读/写/执行），防止越界访问和非法操作，通过​特权级（Ring 0-3）​​ 控制进程访问权限。
- MMU 内存地址虚拟映射单元

### bochs 常用调试命令
xchg bx, bx: bochs 的魔术断点  
r: 查看所有寄存器的值  
c: 跳过当前到下个断点  
s: 单步执行  
u/10: 查看后面的 10 条汇编指令  
info eflags：查看 eflags 的值  
print-stack：查看当前栈  
x/512xw 0x7c00：查看 0x7c00 处的内存，显示后面 512 个字  
break 0x7c00: 下次断点在 0x7c00   
q：退出  
